%{
/**
 * @brief Abstract Syntax Tree evaluator.
 *
 * @par
 * Copyright Jeremy Wright (c) 2012
 * Creative Commons Attribution-ShareAlike 3.0 Unported License.
 */
#include <iostream>
#include <stdlib.h>
#include <list>
#include "ast_parser.h"
#include <cstring>

using namespace std;

int line_num = 1;  //Track the current line number we are processing.

int yylex();
void yyerror(char * s);

%}

%start stmtlist

%union {
  int num;
  IExpression *iexp;
  list<IStatement *> *stmts;
  IStatement *st;
}

%error-verbose

%token <num> NUMBER
%left '&'
%left PERCENT_EXPR
%right '@'
%type <iexp> exp 
%type <stmts> stmtlist
%type <st> stmt

%%


stmtlist : stmtlist '\n' { $$ = $1; } /* epsilon rule */         
         | stmtlist stmt '\n'
            { 
                $$ = $1; //Copy the statement to the next line
                $2->Print(); //Print the AST
                $2->Execute(); // Execute the statement
                line_num++; //Move to the next line.
            }
         | stmtlist error '\n'
	        { 
                $$ = $1; //Copy the statement list
                yyclearin; //Clear the parsers
                yyerrok; //Call the error function to output lexical/syntax error
                line_num++; //Increment the line number to move on.
            } 
         |  
           { $$ = new list<IStatement*>(); }  /* epsilon rule */
;

stmt: exp { $$ = new Statement($1); } /* statement rule starts off the expression */; 

exp:
		NUMBER                      { $$ = new NumberTerminal($1); }
	|	exp '&' exp                 {  $$ = new AmpersandExpression($1, $3); }
    |   '%' exp %prec PERCENT_EXPR  { $$ = new PercentExpression($2); }
	|	exp '@' exp                 {  $$ = new AtExpression($1, $3); }
	|	'(' exp ')'                 { $$ = $2; }
;
 
%%

/* Example lexer from the Bison user's guide. */
int yylex ()
{
    int c;

    /* skip white space  */
    while ((c = getchar ()) == ' ' || c == '\t')  ;
    /* process numbers   */
    if (c == '.' || isdigit (c))
    {
        ungetc (c, stdin);
        scanf ("%d", &yylval);
        return NUMBER;
    }

    /* return end-of-file  */
    if (c == EOF)                            
        return 0;
    /* return single chars */
    return c;                                
}


int main()
{
    yyparse(); //Just run the parser. The Parser drives the whole program
    //The example test files have 1 empty newline at the very end of the file.
    cout << endl; // :-(
}

/* Called by yyparse on error */
void yyerror (char* s)  
{
    //Look through the error message from bison, if it says $undefined then we have a "lexical error"
    //if it says $undefined then we have a "lexical error"
    //Otherwise we have a "syntax error"
    if(strstr(s, "undefined") != NULL)
    {
        printf("line %d lexical error\n", line_num);
    }
    else
    {
        printf("line %d syntax error\n", line_num);
    }

}
